\documentclass[a4paper]{article}

\usepackage[svgnames]{xcolor}
\usepackage{booktabs}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=up]{caption}
\usepackage{fancyvrb}
\usepackage[margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{siunitx}
\usepackage{tikz}
\usepackage{todonotes} % Only for drafting
\usepackage{wrapfig}

\usetikzlibrary{positioning,shapes}

% Args are module name, filename, caption text
% \newcommand{\modulelisting}[3]{
%   \begin{listing}[tp]
%     \linespread{.9}\inputminted[fontsize=\scriptsize,linenos]{systemverilog}{#2}
%     \caption{#3}
%     \label{lst:#1}
%   \end{listing}
% }
\newcommand{\modulelisting}[3]{
  \captionof{listing}{#3\label{lst:#1}}
  \linespread{.9}\inputminted[frame=single,fontsize=\scriptsize,linenos]{systemverilog}{#2}
  \vspace{20pt}
}

% Args are module name, caption text
\newcommand{\waveformfigure}[2]{
  \begin{figure}[tp]
    \centering\includegraphics[width=\textwidth]{assets/waveforms/#1}
    \caption{#2}
    \label{fig:wave:#1}
  \end{figure}
}

% Args are module name, caption text
\newcommand{\rtlfigure}[2]{
  \begin{figure}[tp]
    \centering\includegraphics[width=\textwidth]{assets/rtl/#1}
    \caption{#2}
    \label{fig:rtl:#1}
  \end{figure}
}

\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

\title{ELEC2221 D1: Design and Test of a Sequential Multiplier}
\author{Kier Davis \\
Username: kad2g15 \\
Course: MEng Electronic Engineering \\
Tutor: Dr. Klaus-Peter Zauner \\
Lab group: F17 \\
Lab session: November 21, 2016}

\begin{document}

\maketitle

\todo[inline]{Write about Synplify optimising away the state machine due to the lack of a route from DONE back to IDLE}

\begin{abstract}
  A 4-bit unsigned sequential multiplier was implemented in SystemVerilog. The multiplier was thoroughly tested by preparing testbenches for each component of the multiplier, then simulating them in ModelSim. The design was then synthesised for and downloaded onto a Lattice MachXO2 CPLD and tested manually. Finally, the multiplier was extended to operate on 8-bit numbers before being simulated and synthesised again.
\end{abstract}

% Shift+add in one clock cycle
% All modules parameterised by N -> easy 8 bit extension
% Testbenches use assertions

\section{Adder design, simulation and synthesis}
\label{sec:adder}

The adder was implemented as an integrated part of the \texttt{multiplier\_datapath} module. It takes as inputs the current state of the \texttt{a} register and a signal named \texttt{addend}, and produces a 4-bit \texttt{sum} and a 1-bit \texttt{carry}. The value of \texttt{addend} is chosen based on the state of the least significant bit of \texttt{q}. If this bit is zero, \texttt{addend} is set to zero, and so the output of the adder is equal to \texttt{a}; that is, no actual addition is performed. If, however, the LSB of \texttt{q} is one, \texttt{addend} is set to \texttt{multiplicand}, and so the output of the adder is the sum of \texttt{a} and \texttt{multiplicand}.

\subsection{Implementation}
\label{sec:adder:impl}

The adder itself is implemented on line 72 of Listing~\ref{lst:multiplier_datapath}, and the multiplexer that produces the \texttt{addend} is implemented on line 70.

\subsection{Simulation}
\label{sec:adder:sim}

The adder was not simulated on its own, but only as a part of \texttt{multiplier\_datapath}; see Section~\ref{sec:reg:sim} for further details.

It can be seen from the results of running the simulation of \texttt{multiplier\_datapath} in ModelSim (illustrated in Figure~\ref{fig:wave:test_multiplier_datapath}) that at the clock edge occurring at time \SI{8000}{\milli\second}, the value of the \texttt{product} signal changes from \texttt{0101 1001} to \texttt{1000 0100}. \texttt{product} is simply the concatenation of the \texttt{a} and \texttt{q} registers, so \texttt{a} must change from \texttt{0101} to \texttt{1000} and \texttt{q} must change from \texttt{1001} to \texttt{0100}. This is consistent with the results obtained by working through the method by hand:

\vspace{10pt}
\begin{tabular}{ll}
\mintinline{text}{  0101 1001} & Initial values of a and q \\
\mintinline{text}{+ 1011     } & Addend = multiplicand (1011), since LSB of q is 1 \\
\mintinline{text}{------     } & \\
\mintinline{text}{1 0000     } & Sum and carry \\
\mintinline{text}{1 0000 1001} & Same as first line, but with a replaced by sum/carry \\
\mintinline{text}{  1000 0100} & Resulting of shifting previous line right by one place \\
\end{tabular}
\vspace{10pt}

This transition, and all other transitions of the \texttt{product} signal, are verified by assertions in the simulation. We can deduce that the adder is functioning correctly.

\section{Register design, simulation and synthesis}
\label{seg:reg}

The registers were implemented in the \texttt{multiplier\_datapath} module, together with the adder/shifter.

The \texttt{multiplier\_datapath} module has two 4-bit data inputs, \texttt{multiplicand} and \texttt{multiplier}. These are the two input numbers to the multiplier, and are equivalent to \texttt{M} and \texttt{Qin} respectively in the sample code. Similarly, there is one 8-bit data output, \texttt{product}, which is equivalent to \texttt{AQ} in the sample code.

The module takes two control signals, \texttt{do\_init} and \texttt{do\_shift}, in addition to the clock and asynchronous reset signals. If \texttt{do\_init} is asserted during a rising clock edge, the \texttt{a} and \texttt{q} registers are loaded with their initial values (0 and \texttt{multiplier} respectively). If \texttt{do\_shift} is asserted during a rising clock edge, then \texttt{multiplicand} is conditionally added to \texttt{a}, and then \texttt{a} and \texttt{q} are shifted right by one place, completing one iteration of the multiplication algorithm in a single clock cycle.

\subsection{Implementation}
\label{sec:reg:impl}

The source code of the \texttt{multiplier\_datapath} module is given in Listing~\ref{lst:multiplier_datapath}.

\subsection{Simulation}
\label{sec:reg:sim}

A testbench for the \texttt{multiplier\_datapath} module was prepared. Its source code is given in Listing~\ref{lst:test_multiplier_datapath}. The testbench was then simulated using ModelSim, giving the waveform diagram shown in Figure~\ref{fig:wave:test_multiplier_datapath}. After correcting some minor syntax errors, the testbench and the module under test worked first time, without any assertions failing.

The testbench begins with the reset signal active, and checks that the registers \texttt{a} and \texttt{q} (whose values are concatenated to form the signal \texttt{product}) are reset to zero. It then releases the system from reset, and asserts the \texttt{do\_init} for one clock cycle, checking that \texttt{q} is set to 6, the value arbitrarily chosen for the second multiplier input. It then asserts \texttt{do\_shift} for four of the five following clock cycles, checking the state of the registers at each stage. The results of these operations can be observed in Figure~\ref{fig:wave:test_multiplier_datapath}.

\waveformfigure{test_multiplier_datapath}{Waveform of the \texttt{test\_multiplier\_datapath} testbench. Numbers shown in the waveform traces are in hexadecimal.}

\subsection{Synthesis}
\label{sec:reg:synth}

The RTL generated for the \texttt{multiplier\_datapath} module during the synthesis process is shown in Figure~\ref{fig:rtl:multiplier_datapath}.

\rtlfigure{multiplier_datapath}{Diagram of the synthesised RTL generated for the \texttt{multiplier\_datapath} module by Synplify Pro.}

\section{Sequencer design, simulation and synthesis}
\label{sec:seq}

The multiplier is controlled by an algorithmic state machine (ASM), which is implemented in the \texttt{multiplier\_controller} module. It uses an auxillary 2-bit counter to store the number of remaining cycles of the shift/add operation. This counter has two control signal inputs, \texttt{do\_preset} and \texttt{do\_decrement}. \texttt{do\_preset} causes the value of the counter to its maximum value (3) on the next clock cycle, while \texttt{do\_decrement} causes the value of the counter to be decreased by 1 on the next clock cycle. It has only one output, \texttt{is\_zero}, which is high if the counter is equal to zero.

%\begin{wrapfigure}{r}{.5\textwidth}
\begin{figure}[tp]
  \centering
  \input{asmchart.tex}
  \caption{An ASM chart outlining the operation of the multiplier. Rectangular nodes represent states, and arrows represent possible transition paths. The text inside each state node lists the unconditional outputs that are active during that state; the name of the state is instead given by the label at the top-right corner of the node. Rounded rectangles represent conditional outputs that should be asserted only when the transition path is taken. Diamonds represent decisions (input tests).}
  \label{fig:asm}
%\end{wrapfigure}
\end{figure}

The state machine, illustrated in Figure~\ref{fig:asm}, has three states named Idle, Working and Done. The system begins in the Idle state. When the \texttt{start} signal goes high, the system moves to the Working state. On this transition, the \texttt{a} and \texttt{q} registers are initialised by setting the datapath's \text{do\_init} signal high, and the counter is set to its maximum value by settings its \texttt{do\_preset} signal high.

While in the Working state, the datapath's \texttt{do\_shift} control input is held high, causing the \texttt{a} and \texttt{q} registers to be continually shifted and added. The state of the \texttt{is\_zero} signal is checked on each clock cycle; if it is high, then the system moves to the Done state, else it decreases the value of the counter by one by asserting the \texttt{do\_decrement} signal. Since \texttt{do\_shift} is still asserted when the counter's value is zero, it will be high for four clock cycles in a row, resulting in four iterations of the shift/add operation being applied to the \texttt{a} and \texttt{q} registers.

In the Done state, the system holds the \texttt{ready} output high, signalling the end of computation. It waits for the \texttt{start} input to go low again before transitioning back to the Idle state.

\subsection{Implementation}
\label{sec:seq:impl}

The 2-bit counter used for counting the number of remaining iterations of the shift/add operation is implemented in the \texttt{multiplier\_counter} module, whose source code is given in Listing~\ref{lst:multiplier_counter}. The remainder of the state machine is implemented in the \texttt{multiplier\_controller} module, whose source code is given in Listing~\ref{lst:multiplier_controller}.

\subsection{Simulation}
\label{sec:seq:sim}

A testbench for the counter was prepared; its source code is given in Listing~\ref{lst:test_multiplier_counter}. Running this testbench through ModelSim gives the waveform shown in Figure~\ref{fig:wave:test_multiplier_counter}. After cleaning up minor syntax errors, the simulation ran first time with all assertions passing.

The testbench begins with the reset input set to low, resetting the counter to zero. At time \SI{2800}{\milli\second}, the \texttt{do\_preset} input is asserted, causing the count to be set to the maximum value (3) at the next clock edge (time \SI{3000}{\milli\second}). This signal is then de-asserted and the \texttt{do\_decrement} signal held high for three clock cycles. It can be observed that the count successfully decrements on each clock cycle that \texttt{do\_decrement} is held high for, eventually returning to zero. This behaviour is visible in the diagram.

\waveformfigure{test_multiplier_counter}{Waveform of the \texttt{test\_multiplier\_counter} testbench. Numbers shown in the waveform traces are in hexadecimal.}

Similarly, a testbench for the controller was also prepared. Listing~\ref{lst:test_multiplier_controller} gives the source code of this testbench, and Figure~\ref{fig:wave:test_multiplier_controller} shows the waveform produced by simulating the testbench in ModelSim. The testbench manipulates the \texttt{start} and \texttt{counter\_is\_zero} inputs to behave behave as if the system was performing multiplication. The controller can be seen to correctly assert \texttt{datapath\_do\_init}, then \texttt{datapath\_do\_shift} for four clock cycles, as expected.

\waveformfigure{test_multiplier_controller}{Waveform of the \texttt{test\_multiplier\_controller} testbench. Numbers shown in the waveform traces are in hexadecimal.}

\subsection{Synthesis}
\label{sec:seq:synth}

Diagrams of the generated RTL logic for the counter and sequencer were extracted from the synthesis of the design and are presented in Figures~\ref{fig:rtl:multiplier_counter} and \ref{fig:rtl:multiplier_controller} respectively. The state machine at the core of the diagram for the sequencer has the transition diagram displayed in Figure~\ref{fig:fsm} and the transition table shown in Table~\ref{tab:fsm}.

\rtlfigure{multiplier_counter}{Diagram of the synthesised RTL generated for the \texttt{multiplier\_counter} module by Synplify Pro.}

\rtlfigure{multiplier_controller}{Diagram of the synthesised RTL generated for the \texttt{multiplier\_controller} module by Synplify Pro.}

\begin{figure}[tp]
  \centering\includegraphics[width=.3\textwidth]{assets/rtl/fsm}
  \caption{State transition diagram generated for the \texttt{multiplier\_controller} module by Synplify Pro.}
  \label{fig:fsm}
\end{figure}

\begin{table}[tp]
  \centering
  \begin{tabular}{lll}
    \toprule
    From state & To state & Condition \\
    \midrule
    \texttt{00} & \texttt{00} & \texttt{!start} \\
    \texttt{00} & \texttt{01} & \texttt{start} \\
    \texttt{01} & \texttt{01} & \texttt{!counter\_is\_zero} \\
    \texttt{01} & \texttt{10} & \texttt{counter\_is\_zero} \\
    \texttt{10} & \texttt{00} & \texttt{!start} \\
    \texttt{10} & \texttt{10} & \texttt{start} \\
    \bottomrule
  \end{tabular}
  \caption{State transition table generated for the \texttt{multiplier\_controller} module by Synplify Pro.}
  \label{tab:fsm}
\end{table}

\section{Multiplier design, simulation and synthesis}
\label{sec:mult}

The \texttt{multiplier} module encapsulates the \texttt{multiplier\_datapath}, \texttt{multiplier\_counter} and \texttt{multiplier\_controller} modules, linking the internal signals together. Its interface consists of the data inputs \texttt{multiplicand} and \texttt{multiplier}, the data output \texttt{product} and the control signals \texttt{start} and \texttt{ready}, as well as clock and asynchronous reset signals.

A seperate module, \texttt{machxo2\_pico\_frontend}, connects the multiplier's logical inputs and outputs to the hardware of the MachXO2 Pico board. This module creates instances of:
\begin{itemize}
  \item the multiplier itself
  \item the internal oscillator that produces the master clock
  \item the frequency divider that derives the multiplier's clock signal from the master clock
  \item the switch debouncer for the \texttt{start} button
\end{itemize}
Additionally, it defines the values of the multiplier's data inputs, \texttt{multiplicand} and \texttt{multiplier}. Since there are no physical switches available to control these inputs, they are hard-wired to constants. Values of 11 and 6 were arbitrarily chosen.

The internal oscillator is an instance of \texttt{OSCH} with a nominal frequency of \SI{4.16}{\mega\hertz}. The frequency divider, implemented in the \texttt{freq\_divider} module, uses a 22-bit counter to reduce this frequency to \SI{0.99}{\hertz}, allowing each step of the multiplication operation to be observed in real time.

The switch debouncer uses a simple counter to detect when the input becomes stable. The counter is incremented by one for every consecutive clock cycle in which the input differs from the current output. If the input returns to the same logic value as the output at any point, the counter is reset to zero. Once the counter reaches its maximum value, the input is assumed to have stopped oscillating, and so the current output state is updated to the same value as the input.

\subsection{Implementation}
\label{sec:mult:impl}

The source code of the \texttt{multiplier}, \texttt{freq\_divider}, \texttt{debouncer} and \texttt{machxo2\_pico\_frontend} modules is given in Listings~\ref{lst:multiplier}, \ref{lst:freq_divider}, \ref{lst:debouncer} and \ref{lst:machxo2_pico_frontend} respectively.

\subsection{Simulation}
\label{sec:mult:sim}

A testbench for the multiplier as a whole was written; its source code can be found in Listing~\ref{lst:test_multiplier}. Figure~\ref{fig:wave:test_multiplier} illustrates the result of running this testbench in ModelSim. It can be observed that an entire multiplication operation is completed in response to the \texttt{start} signal being brought high. The testbench contains assertions to check the values of \texttt{product} and \texttt{ready} at each clock cycle.

\waveformfigure{test_multiplier}{Waveform of the \texttt{test\_multiplier} testbench. Numbers shown in the waveform traces are in hexadecimal.}

Similarly, the \texttt{freq\_divider} module was also simulated in ModelSim. The testbench code is presented in Listing~\ref{lst:test_freq_divider}, producing the waveform shown in Figure~\ref{fig:wave:test_freq_divider}. For the purposes of simulation, the counter length was reduced from 22 bits to 8 bits, greatly reducing the length of time the simulation runs for. It can be seen that the output, \texttt{out\_clock}, has a much lower frequency than \texttt{in\_clock}. The testbench verifies through the use of assertions that the output frequency is $1/256$ the input frequency.

\waveformfigure{test_freq_divider}{Waveform of the \texttt{test\_freq\_divider} testbench. Numbers shown in the waveform traces are in hexadecimal.}

Finally, the \texttt{debouncer} was also simulated using the testbench displayed in Listing~\ref{lst:test_debouncer}. The testbench generates an input signal that oscillates rapidly at first, but decays in frequency over time. As demonstrated in Figure~\ref{fig:wave:test_debouncer}, the debouncer correctly smoothes this signal to a single step.

\waveformfigure{test_debouncer}{Waveform of the \texttt{test\_debouncer} testbench. Numbers shown in the waveform traces are in hexadecimal.}

The \texttt{machxo2\_pico\_frontend} was not simulated as it depends on the built-in \texttt{OSCH} module, which is not available in external simulation tools such as ModelSim. Potentially, a simulatable drop-in replacement for \texttt{OSCH} could have been prepared, but \texttt{machxo2\_pico\_frontend} was not deemed to be complex enough to warrant this.

\subsection{Synthesis}
\label{sec:mult:synth}

The entire design was synthesised using Synplify Pro as part of the Lattice Diamond design flow. A block diagram of the system can be generated using the RTL netlist viewer; this is shown in Figure~\ref{fig:rtl:machxo2_pico_frontend}.

\rtlfigure{machxo2_pico_frontend}{Block diagram of the synthesised RTL generated for the top-level \texttt{machxo2\_pico\_frontend} module by Synplify Pro. Five of the eight output buffers (located at the bottom-right of the diagram) have been omitted for brevity.}

\todo[inline]{Anything more to say about this?}

\section{Extensions}
\label{sec:ext}

\subsection{8-bit datapath}
\label{sec:ext:8bit}

\todo[inline]{todo}

\section{Conclusion}
\label{sec:con}

\todo[inline]{todo}

\section{References}

\todo[inline]{sample code used as inspiration}
\todo[inline]{shift/add algo}
\todo[inline]{debounce algo}

\newpage
\section{Source code}

All source code is mirrored online at \url{https://github.com/kierdavis/multiplier}.

\modulelisting{multiplier_datapath}{../src/multiplier/multiplier_datapath.sv}
  {Source code of the \texttt{multiplier\_datapath} module, which contains the data registers $a$ and $q$ and the add/shift computation logic.}

\newpage

\modulelisting{test_multiplier_datapath}{../src/multiplier/test/test_multiplier_datapath.sv}
  {Source code of the \texttt{test\_multiplier\_datapath} module, which tests the operation of the data registers and add/shift computation logic.}

\modulelisting{multiplier_counter}{../src/multiplier/multiplier_counter.sv}
  {Source code of the \texttt{multiplier\_counter} module, which contains the 2-bit counter that records the number of remaining iterations of the algorithm.}

\modulelisting{test_multiplier_counter}{../src/multiplier/test/test_multiplier_counter.sv}
  {Source code of the \texttt{test\_multiplier\_counter} module, which tests the 2-bit counter used to keep track of the remaining number of iterations.}

\modulelisting{multiplier_controller}{../src/multiplier/multiplier_controller.sv}
  {Source code of the \texttt{multiplier\_controller} module, which contains the state machine that controls the multiplier's operation.}

\modulelisting{test_multiplier_controller}{../src/multiplier/test/test_multiplier_controller.sv}
  {Source code of the \texttt{test\_multiplier\_controller} module, which tests the operation of the state machine.}

\modulelisting{multiplier}{../src/multiplier/multiplier.sv}
  {Source code of the encapsulating module \texttt{multiplier}.}

\newpage

\modulelisting{test_multiplier}{../src/multiplier/test/test_multiplier.sv}
  {Source code of the \texttt{test\_multiplier} module, which tests the operation of the multiplier as a whole.}

\modulelisting{freq_divider}{../src/util/freq_divider.sv}
  {Source code of the \texttt{freq\_divider} module, which implements a divide-by-$2^{22}$ frequency divider.}

\modulelisting{test_freq_divider}{../src/util/test/test_freq_divider.sv}
  {Source code of the \texttt{test\_freq\_divider} module, which tests the frequency divider.}

\modulelisting{debouncer}{../src/util/debouncer.sv}
  {Source code of the \texttt{debouncer} module, which implements a simple switch debouncer for the start button.}

\modulelisting{test_debouncer}{../src/util/test/test_debouncer.sv}
  {Source code of the \texttt{test\_debouncer} module, which tests the start button debouncer.}

\modulelisting{machxo2_pico_frontend}{../src/frontends/machxo2_pico_frontend.sv}
  {Source code of the MachXO2 Pico frontend module \texttt{machxo2\_pico\_frontend}.}

\end{document}
